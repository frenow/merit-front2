{"version":3,"sources":["webpack://cachePolyfill/webpack/universalModuleDefinition","webpack://cachePolyfill/webpack/bootstrap","webpack://cachePolyfill/./src/cache.js","webpack://cachePolyfill/./src/cache-storage.js","webpack://cachePolyfill/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","map","WeakMap","wm","requires","args","length","TypeError","isReq","req","Request","openDB","Promise","rs","open","indexedDB","onupgradeneeded","db","result","createObjectStore","keyPath","autoIncrement","createIndex","unique","onsuccess","Cache","cacheName","_classCallCheck","this","set","matchAll","apply","arguments","undefined","method","tx","transaction","objectStore","index","openCursor","IDBKeyRange","only","cursor","url","reqUrl","initData","assign","resUrl","res","Response","body","push","continue","oncomplete","request","addAll","requests","_this","results","_loop","async","_req","test","clone","fetch","then","status","ok","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","err","return","all","a","put","_toConsumableArray","delete","split","varyHeaders","headers","includes","bodyUsed","cache","statusText","arrayBuffer","replace","reqMethod","rj","onerror","error","options","ignoreMethod","caches","deleted","primaryKey","folder","_options$ignoreMethod","_options$ignoreSearch","ignoreSearch","search","filter","getAll","response","CacheStorage","keys","getAllKeys","key","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","match","toStringTag","_cacheStorage","forEach"],"mappings":"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","file":"cache.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cachePolyfill\"] = factory();\n\telse\n\t\troot[\"cachePolyfill\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","const map = new WeakMap()\nconst wm = o => map.get(o)\n\nconst requires = (i, args) => {\n  if (args.length < i)\n    throw new TypeError(`${i} argument required, but only ${args.length} present.`)\n}\n\nconst isReq = req => req && req instanceof Request\nconst isRes = res => res && res instanceof Response\n\nfunction openDB() {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = () => {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', { keyPath: 'cacheName' })\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass Cache {\n  constructor(cacheName) {\n    map.set(this, cacheName)\n  }\n\n  /**\n   * Returns a Promise that resolves to the response associated\n   * with the first matching request in the Cache object.\n   *\n   * @param  {[type]}  args [description]\n   * @return {Promise}      [description]\n   */\n  async match(...args) {\n    return (await this.matchAll(...args))[0]\n  }\n\n  // Returns a Promise that resolves to an array\n  // of all matching requests in the Cache object.\n  async matchAll(req, options = {}) {\n    if (req.method === 'HEAD') return []\n\n    const cacheName = wm(this)\n    const db = await openDB()\n    const result = []\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readonly')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const request = index.openCursor(IDBKeyRange.only(cacheName));\n    request.onsuccess = function() {\n      let cursor = this.result;\n\n      if (cursor) {\n        if ((req.url || req) === cursor.value.reqUrl) {\n          const initData = Object.assign({\n            url: cursor.value.resUrl\n          }, cursor.value)\n\n          const res = new Response(cursor.value.body, initData)\n          result.push(res)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(result)\n    )\n  }\n\n  // Takes a URL, retrieves it and adds the resulting response\n  // object to the given cache. This is fuctionally equivalent\n  // to calling fetch(), then using put() to add the results to the cache\n  async add(request) {\n    requires(1, arguments)\n    return this.addAll([request])\n  }\n\n  // Takes an array of URLs, retrieves them, and adds the\n  // resulting response objects to the given cache.\n  async addAll(requests) {\n    requires(1, arguments)\n\n    let results = []\n\n    for (let req of requests) {\n      req = new Request(req)\n\n      if (!/^((http|https):\\/\\/)/.test(req.url))\n        throw new TypeError(`Add/AddAll does not support schemes other than \"http\" or \"https\"`)\n\n      if (req.method !== 'GET')\n        throw new TypeError(`Add/AddAll only supports the GET request method`)\n\n      let clone = req.clone()\n\n      await fetch(req).then(res => {\n        if (res.status === 206)\n          throw new TypeError('Partial response (status code 206) is unsupported')\n\n        if (!res.ok)\n          throw new TypeError('Request failed')\n\n        results.push([req, res])\n      })\n    }\n\n    await Promise.all(results.map(a => this.put(...a)))\n  }\n\n\n  /**\n   * Takes both a request and its response and adds it to the given cache.\n   *\n   * @param  {Request|String}  req  [description]\n   * @param  {Response}        res  [description]\n   * @return {Promise}              [description]\n   */\n  async put(req, res) {\n    requires(2, arguments)\n\n    req = isReq(req) ? req : new Request(req)\n\n    await this.delete(req)\n\n    if (!/^((http|https):\\/\\/)/.test(req.url))\n      throw new TypeError(`Request scheme '${req.url.split(':')[0]}' is unsupported`)\n\n    if (req.method !== 'GET')\n      throw new TypeError(`Request method '${req.method}' is unsupported`)\n\n    if (res.status === 206)\n      throw new TypeError('Partial response (status code 206) is unsupported')\n\n    let varyHeaders = res.headers.get('Vary')\n\n    if (varyHeaders && varyHeaders.includes('*'))\n      throw new TypeError('Vary header contains *')\n\n    if (res.body != null)\n      if (res.bodyUsed)\n        throw new TypeError('Response body is already used')\n\n    let folder = wm(this)\n    let cache = {\n      cacheName: folder,\n      headers: [...res.headers],\n      status: res.status,\n      statusText: res.statusText,\n      body: await res.arrayBuffer(),\n      reqUrl: req.url.replace(/#.*$/,''),\n      resUrl: res.url.replace(/#.*$/,''),\n      reqMethod: req.method\n    }\n\n    const db = await openDB()\n\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('caches', 'readwrite')\n      const store = tx.objectStore('caches')\n\n      // Add some data\n      store.put(cache);\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n  }\n\n  // Finds the Cache entry whose key is the request, and if found,\n  // deletes the Cache entry and returns a Promise that resolves to true.\n  // If no Cache entry is found, it returns false.\n  async delete(request, options = {}) {\n    requires(1, arguments)\n    const cacheName = wm(this)\n\n    const { ignoreMethod } = options\n    const r = isReq(request) ? request : new Request(request)\n    if (!['GET', 'HEAD'].includes(r.method) && ignoreMethod)\n      return false\n\n    const { method } = r\n    const url = r.url.replace(/#.*$/,'')\n    const db = await openDB()\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readwrite')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const query = index.openCursor(IDBKeyRange.only(cacheName));\n\n    let deleted = false\n\n    query.onsuccess = function() {\n      const cursor = this.result;\n\n      if (cursor) {\n        if (url === cursor.value.reqUrl && (ignoreMethod || method === cursor.value.reqMethod)) {\n          deleted = true\n          caches.delete(cursor.primaryKey)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(deleted)\n    )\n  }\n\n  // Returns a Promise that resolves to an array of Cache keys.\n  async keys(request, options = {}) {\n    let url\n    const folder = wm(this)\n    const {\n      ignoreMethod = false,\n      ignoreSearch = false\n    } = options\n\n    // using new Request to normalize fragment and trailing slash\n    if (request !== undefined) {\n      request = new Request(request)\n\n      url = request.url.split('#')[0]\n\n      if (request.method !== 'GET' && !ignoreMethod) return []\n    }\n\n    const search = request === undefined ? a => a : a => a.filter(a => {\n      if (ignoreSearch) {\n        a = a.reqUrl.split('?')[0]\n        url = url.split('?')[0]\n      } else {\n        a = a.reqUrl\n      }\n\n      return a === url\n    })\n\n    const db = await openDB()\n\n    const responses = await new Promise(rs => {\n      const tx = db.transaction('caches', 'readonly')\n      const store = tx.objectStore('caches')\n      const cacheName = store.index('cacheName');\n      const request = cacheName.getAll(IDBKeyRange.only(folder))\n      request.onsuccess = () => rs(request.result)\n    })\n\n    return search(responses).map(response => new Request(response.reqUrl))\n  }\n}\n\nmodule.exports = Cache\n","const Cache = require('./cache')\n\nfunction openDB() {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = function() {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', {keyPath: 'cacheName'})\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      const e = cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass CacheStorage {\n\n  /**\n   * [delete description]\n   * @return {[type]} [description]\n   */\n  async delete(cacheName) {\n    // Should resolve to false if there is nothing to delete\n    const keys = await this.keys()\n    if (!keys.includes(cacheName)) {\n      return false\n    }\n\n    const db = await openDB()\n\n    // Start a new transaction\n    var tx = db.transaction(['storages', 'caches'], 'readwrite')\n    var store = tx.objectStore('storages')\n    var request = store.delete(cacheName)\n\n    var caches = tx.objectStore('caches')\n    var index = caches.index('cacheName')\n    var request = index.getAllKeys(IDBKeyRange.only(cacheName));\n\n    request.onsuccess = function(tx) {\n      for (let key of this.result) {\n        caches.delete(key)\n      }\n    }\n\n    return new Promise((rs, rj) => {\n      tx.oncomplete = () => rs(true)\n      tx.onerror = () => rj(false)\n    })\n  }\n\n\n  /**\n   * [has description]\n   * @return {Boolean} [description]\n   */\n  has(cacheName) {\n    return this.keys().then(keys => keys.includes(cacheName))\n  }\n\n\n  /**\n   * resolves with an array containing strings corresponding to all of the named\n   * Cache objects tracked by the CacheStorage.\n   * Use this method to iterate over a list of all the Cache objects.\n   *\n   * @return <Promise>Array keyList\n   */\n  async keys() {\n    const db = await openDB()\n\n    // Start a new transaction\n    var tx = db.transaction('storages', 'readonly')\n    var store = tx.objectStore('storages')\n    var keys = store.getAllKeys()\n\n    return new Promise(rs =>\n      keys.onsuccess = () => rs(keys.result)\n    )\n  }\n\n\n  /**\n   * Checks if a given Request is a key in any of the Cache objects\n   * that the CacheStorage object tracks and returns a Promise that\n   * resolves to that match.\n   *\n   * @return Promise\n   */\n  async match(...args) {\n    let keys = await this.keys()\n\n    for (let key of keys) {\n      let cache = await this.open(key)\n      let result = await cache.match(...args)\n      if (result) return result\n    }\n  }\n\n\n  /**\n   * Resolves to the Cache object matching the cacheName\n   * (a new cache is created if it doesn't exist.)\n   *\n   * @return {[type]} [description]\n   */\n  async open(cacheName) {\n    if (arguments.length < 1)\n      throw new TypeError(`${i} argument required, but only ${arguments.length} present.`)\n\n    const db = await openDB()\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('storages', 'readwrite')\n      const store = tx.objectStore('storages')\n\n      // Add some data\n      store.put({ cacheName });\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n\n    return new Cache(cacheName)\n  }\n\n\n  /**\n   * [description]\n   * @return {[type]} [description]\n   */\n  [Symbol.toStringTag]() {\n    return 'CacheStorage'\n  }\n}\n\nmodule.exports = {\n  Cache,\n  CacheStorage,\n  caches: new CacheStorage\n}\n","export * from './cache-storage';\n"],"sourceRoot":""}